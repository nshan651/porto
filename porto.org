#+title: Porto
#+options: tex:t toc:nil
#+startup: inlineimages latexpreview

My portable, private home server infrastructure.

#+name: arch
[[file:./docs/arch.svg]]

#+html: <details><summary>Diagram Source</summary>
#+begin_src dot :tangle docs/arch.dot :mkdirp yes :file ./docs/arch.svg :cmdline -Kdot -Tsvg :results silent
  digraph G {
      fontname="Helvetica,Arial,sans-serif";
      node [fontname="Helvetica,Arial,sans-serif", shape=rect, style="rounded,filled", fillcolor="#2d2d2d", fontcolor=white, color=white];
      edge [fontname="Helvetica,Arial,sans-serif", color=white, fontcolor=white];
      bgcolor="#1f1f1f";
      rankdir=TB;
      nodesep=0.7;
      ranksep=0.9;
      compound=true; // Allows edges to connect to clusters
      splines=polyline;

      internet [label="Internet", shape=none, fillcolor=none];

      subgraph cluster_external {
        bgcolor="#601000";
        label="External Compose";
        fontcolor=white;
        color=white;
        style=rounded;

        public_rp [label="External Reverse Proxy"];
        website [label="Website\n(public.duckdns.org)"];
        headscale [label="Headscale\n(hs.public.duckdns.org)"];

        // Connections
        public_rp -> website;
        public_rp -> headscale;
      }

      internet -> public_rp [lhead=cluster_external];

      // Cluster_Tailnet Cluster
      subgraph cluster_tailnet {
        bgcolor="#013312";
        label="Tailnet";
        fontcolor=white;
        color=white;
        style=rounded;

        // Tailnet nodes.
        phone [label="Phone"];
        laptop [label="Laptop"];
        vps [label="VPS"];

        phone -> laptop [dir=none, constraint=false];
        laptop -> vps [dir=none, constraint=false];

        // Connect mesh to tailscale_node
        { phone; laptop; vps } -> docker_ts_node [dir=none];

        // Cluster_Tailnet Cluster
        subgraph cluster_internal {
            bgcolor="#32467a";
            label="Internal Compose";
            fontcolor=white;
            color=white;
            style=rounded;

            docker_ts_node [label="Docker Tailscale Node\n(*.private.duckdns.org)"];
            private_rp [label="Internal Reverse Proxy"];

            service1 [label="Service 1"];
            service2 [label="Service 2"];
            service3 [label="Service 3"];

            docker_ts_node -> private_rp;
            private_rp -> {service1; service2; service3};
        }
      }

      // Connect Headscale to the Cluster_Tailnet
      headscale -> docker_ts_node [lhead=cluster_internal];
    }
#+end_src
#+html: </details>

* Usage
#+begin_src sh
  Usage: make [target]

  Docker compose targets:
    up                Spin up the public and private compose stacks.
    down              Tear down the public and private compose stacks, removing dangling volumes.
    pull              Pull service images.

  Tailscale targets:
    nodes             List existing nodes in the tailnet.
    preauth           Generate a new preauth key.
    pull              Pull service images.

  Authentication:
    secret            Generate a new argon2 hashed password. Run this as `PASS='mypwd123' make secret`.

  Nextcloud:
    rescan            Reload photos in nextcloud.

  Default target:
    help              Show this help message.
#+end_src

** Env
Copy the ~.env_template~ to ~.env~, replacing the environment variables with your own information.
#+begin_src sh :tangle .env_template :mkdirp yes
  # Domain for public-facing services.
  PUBLIC_DOMAIN=mydomain.duckdns.org

  # Entrypoint for Tailscale services.
  CONTROL_DOMAIN=control.duckdns.org

  # ACME email and user.
  EMAIL=admin@mail.com
  USER=admin

  # DNS token for cert mgmt.
  DUCKDNS_TOKEN=

  # Pre-authentication key that allows tailscale client to auto-register with headscale.
  TS_AUTHKEY=

  # Nextcloud DB password.
  DB_PASSWORD=
#+end_src

** Tailscale
Create a user.
#+begin_src sh
  docker exec headscale headscale users create myuser
#+end_src

** Auth
Run ~PASS='mypwd123' make secret~ to generate an argon2 hash of your password.

Copy ~data/authelia/users_database.template.yml~ to ~data/authelia/users_database.yml~, replacing the password section with the argon2 hash we just generated.
#+begin_src yaml :tangle data/authelia/users_database.template.yml :mkdirp yes
  # List of users
  users:
    authelia:
      disabled: false
      displayname: "Authelia User"
      # Password is authelia
      password: "$6$rounds=50000$BpLnfgDsc2WD8F2q$Zis.ixdg9s/UOJYrs56b5QEZFiZECu0qZVNsIYxBaNJ7ucIL.nlxVCT5tqh8KHG8X4tlwCFm5r6NTOZZ5qRFN/"
      email: "authelia@authelia.com"
      groups:
        - "admins"
        - "dev"
#+end_src

* Setup
** Obtaining a Domain Name
Acquiring a domain is a fairly simple process. Domains can registered with any accredited /registrar/, of which there are many to choose from. Popular choices include [[https://www.godaddy.com][GoDaddy]], [[https://www.namecheap.com][Namecheap]], [[https://www.cloudflare.com/products/registrar/][Cloudflare]], and [[https://porkbun.com][Porkbun]], among others. Aside from specialty domains (have fun paying markups for =.ai= TLDs), most domains will only cost a few dollars per year.

My personal recommendation for just starting out is [[https://www.duckdns.org][DuckDNS]] as it's completely free. We'll grab two domains: one for public-facing services (such as the headscale control plane, which needs to be reachable via https. More on that later!), and a second domain for private services on our tailnet.

** Getting a server
A server is a computer that provides information to other computers on a network. That network could be the public internet or a private intranet.

Just like with domain registrars, there are a lot of choices when it comes to server hosting. You can jump straight to using your own hardware, but I'd actually recommend renting a [[https://en.wikipedia.org/wiki/Virtual_private_server][virtual private server (VPS)]] to start. I use [[https://www.hetzner.com/][Hetzner]], but there are many other excellent affordable options.

** DNS Records
With a domain and a server, we can now connect the two using DNS records. DNS (Domain Name System) records are instructions stored on DNS servers that provide information about a domain, such as the IP address associated with it and how to handle requests to that domain.

* Compose
My docker compose stack is split into two files: ~compose.yml~ for public-facing services, and ~compose.internal.yml~ for services on my tailnet.

** Public
*** External Reverse Proxy
#+name: external-proxy
#+begin_src yaml
  external_proxy:
    image: traefik
    container_name: external_proxy
    restart: unless-stopped
    networks:
      - public_net
    command:
      - "--log.level=DEBUG"
      - "--api.insecure=false"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--providers.docker.constraints=Label(`traefik.scope`, `public`)"
      - "--providers.docker.network=public_net"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--entrypoints.web.http.redirections.entrypoint.to=websecure"
      - "--entrypoints.web.http.redirections.entrypoint.scheme=https"
      - "--certificatesresolvers.letsencrypt.acme.dnschallenge=true"
      - "--certificatesresolvers.letsencrypt.acme.dnschallenge.provider=duckdns"
      - "--certificatesresolvers.letsencrypt.acme.email=mail@mail.com"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
      - "--certificatesresolvers.letsencrypt.acme.dnschallenge.disablePropagationCheck=true"
      - "--entrypoints.websecure.http.tls=true"
      - "--entrypoints.websecure.http.tls.certResolver=letsencrypt"
      - "--entrypoints.websecure.http.tls.domains[0].main=${PUBLIC_DOMAIN}"
      - "--entrypoints.websecure.http.tls.domains[0].sans=*.${PUBLIC_DOMAIN}"
      - "--entrypoints.websecure.http.tls.domains[1].main=${CONTROL_DOMAIN}"
      - "--entrypoints.websecure.http.tls.domains[1].sans=*.${CONTROL_DOMAIN}"
    volumes:
      - ./data/traefik/letsencrypt:/letsencrypt
      - /var/run/docker.sock:/var/run/docker.sock:ro
    ports:
      - "80:80"
      - "443:443"
    environment:
      DUCKDNS_TOKEN: "${DUCKDNS_TOKEN}"
#+end_src

*** Website
#+name: website
#+begin_src yaml
  # Personal website
  website:
    image: nginx:latest
    container_name: porto_website
    restart: unless-stopped
    networks:
      - public_net
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.website.rule=Host(`${PUBLIC_DOMAIN}`)"
      - "traefik.http.routers.website.entrypoints=websecure"
      - "traefik.scope=public"
    volumes:
      - /var/www/${PUBLIC_DOMAIN}:/usr/share/nginx/html:ro
#+end_src

*** Headscale
#+name: headscale
#+begin_src yaml
  # VPN Control Plane.
  headscale:
    image: headscale/headscale:latest
    container_name: headscale
    restart: unless-stopped
    networks:
      - public_net
    # ports:
    #   - "50443:50443" # For gRPC.
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.headscale.rule=Host(`hs.${PUBLIC_DOMAIN}`)"
      - "traefik.http.routers.headscale.entrypoints=websecure"
      - "traefik.http.services.headscale.loadbalancer.server.port=8080"
      - "traefik.scope=public"
    volumes:
      - ./config/headscale:/etc/headscale
      - ./data/headscale:/var/lib/headscale
    command: serve
    healthcheck:
      test: ["CMD", "headscale", "health"]
#+end_src

*** Final
#+begin_src yaml :tangle "test/compose.yml" :noweb yes
  services:

    <<external-proxy>>

    <<website>>

    <<headscale>>

  networks:
    public_net:
      driver: bridge
#+end_src
